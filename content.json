{"meta":{"title":"Lokya","subtitle":"Lokya‘s blog","description":"lokya lokya blog","author":"Lokya","url":"https://lokya.github.io","root":"/"},"pages":[{"title":"简介","date":"2019-05-06T08:42:12.708Z","updated":"2019-05-06T08:42:12.708Z","comments":true,"path":"about/index.html","permalink":"https://lokya.github.io/about/index.html","excerpt":"","text":"I am lokya我欲乘风归去，又恐琼楼玉宇，高处不胜寒，起舞弄清影，何似在人间。。。。。。 先写这么多吧。。。。。"},{"title":"","date":"2019-05-03T02:06:32.254Z","updated":"2019-05-03T02:06:32.254Z","comments":true,"path":"mylist/index.html","permalink":"https://lokya.github.io/mylist/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2019-05-05T15:13:20.494Z","updated":"2019-05-05T15:13:20.494Z","comments":true,"path":"blog/categories/index.html","permalink":"https://lokya.github.io/blog/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2019-05-07T01:28:53.737Z","updated":"2019-05-07T01:28:53.737Z","comments":true,"path":"blog/tags/index.html","permalink":"https://lokya.github.io/blog/tags/index.html","excerpt":"","text":""},{"title":"归档","date":"2019-05-06T03:17:19.125Z","updated":"2019-05-06T03:17:19.125Z","comments":true,"path":"blog/archives/index.html","permalink":"https://lokya.github.io/blog/archives/index.html","excerpt":"","text":""}],"posts":[{"title":"too many open files","slug":"notes/note1","date":"2019-06-14T02:43:02.332Z","updated":"2019-06-17T09:48:23.917Z","comments":true,"path":"2019/06/14/notes/note1/","link":"","permalink":"https://lokya.github.io/2019/06/14/notes/note1/","excerpt":"","text":"原因前端Jenkins跑服务时候报错，怎么都跑不起来，我就去服务器手动执行脚本。在build阶段发现服务器报错 too many open files,于是去查找资料找解决方案。 这个报错是只打来文件过多，超过了系统限制的文件数量以及通讯链接数，这边的files不单是文件的意思，也包括打开的通讯链接(比如socket)，正在监听的端口等，也可以叫做句柄(handle)。这个错误通常也可以叫做句柄数超出系统限制。 查看可以使用 ulimit -a 或者 ulimit -n 来查看当前系统最大句柄限制数 12345678910111213141516171819202122$ ulimit -acore file size (blocks, -c) 0data seg size (kbytes, -d) unlimitedscheduling priority (-e) 0file size (blocks, -f) unlimitedpending signals (-i) 127922max locked memory (kbytes, -l) 64max memory size (kbytes, -m) unlimitedopen files (-n) 1024pipe size (512 bytes, -p) 8POSIX message queues (bytes, -q) 819200real-time priority (-r) 0stack size (kbytes, -s) 8192cpu time (seconds, -t) unlimitedmax user processes (-u) 127922virtual memory (kbytes, -v) unlimitedfile locks (-x) unlimited$ limit -n1024 open files那一行就代表系统目前允许单个进程打开的最大句柄数，这里是1024。 同时使用 -n 查看下来也是1024。 修改临时修改ulimit -n 123456789101112131415161718192021222324$ ulimit -n 65535$ ulimit -acore file size (blocks, -c) 0data seg size (kbytes, -d) unlimitedscheduling priority (-e) 0file size (blocks, -f) unlimitedpending signals (-i) 127922max locked memory (kbytes, -l) 64max memory size (kbytes, -m) unlimitedopen files (-n) 65535pipe size (512 bytes, -p) 8POSIX message queues (bytes, -q) 819200real-time priority (-r) 0stack size (kbytes, -s) 8192cpu time (seconds, -t) unlimitedmax user processes (-u) 127922virtual memory (kbytes, -v) unlimitedfile locks (-x) unlimited$ limit -n65535 但这种设置方法在重启后会还原为默认值。 ulimit -n命令非root用户只能设置到4096，想要设置到更大需要sudo权限或者root用户。 修改conf文件，永久配置1234$ vim /etc/security/limits.conf #在最后加入 * soft nofile 65535 * hard nofile 65535 *代表所有用户，可以给特点用户设定句柄最大数值。 1234$ vim /etc/security/limits.conf #在最后加入 jenkins soft nofile 65535 jenkins hard nofile 65535 上面就是把jenkins用户最大句柄数改成65535 之后再查看大小的话可以发现已经修改为 65535 。","categories":[{"name":"linux","slug":"linux","permalink":"https://lokya.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://lokya.github.io/tags/linux/"},{"name":"note","slug":"note","permalink":"https://lokya.github.io/tags/note/"}]},{"title":"变量的解构","slug":"knowledge/es6/lesson_2","date":"2019-06-12T01:44:06.930Z","updated":"2019-06-12T01:47:55.230Z","comments":true,"path":"2019/06/12/knowledge/es6/lesson_2/","link":"","permalink":"https://lokya.github.io/2019/06/12/knowledge/es6/lesson_2/","excerpt":"","text":"(1) 数组12345678let [a, b, c] = [1, 2, 3];// 报错let [foo] = 1;let [foo] = false;let [foo] = NaN;let [foo] = undefined;let [foo] = null;let [foo] = &#123;&#125;; (2) 对象1let &#123; foo, bar &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;; 区分模式还是变量12345678910let obj = &#123; p: [ 'Hello', &#123; y: 'World' &#125; ]&#125;;let &#123; p: [x, &#123; y &#125;] &#125; = obj;x // \"Hello\"y // \"World\" 注意，这时p是模式，不是变量，因此不会被赋值注意: 默认值生效的条件是，对象的属性值严格等于undefined。 (3)字符串看做数组123456const [a, b, c, d, e] = 'hello';a // \"h\"b // \"e\"c // \"l\"d // \"l\"e // \"o\" (4)数值的布尔值12let &#123;toString: s&#125; = 123;s === Number.prototype.toString // true 解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错 (5)例子1234let x = 1;let y = 2;[x, y] = [y, x];","categories":[{"name":"javascript","slug":"javascript","permalink":"https://lokya.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://lokya.github.io/tags/javascript/"},{"name":"ES6","slug":"ES6","permalink":"https://lokya.github.io/tags/ES6/"}]},{"title":"声声慢","slug":"others/miscellany_2","date":"2019-05-09T15:04:08.281Z","updated":"2019-05-09T15:08:26.900Z","comments":true,"path":"2019/05/09/others/miscellany_2/","link":"","permalink":"https://lokya.github.io/2019/05/09/others/miscellany_2/","excerpt":"","text":"声声慢寻寻觅觅，冷冷清清，凄凄惨惨戚戚。乍暖还寒时候，最难将息。三杯两盏淡酒，怎敌他、晚来风急！雁过也，正伤心，却是旧时相识。 满地黄花堆积，憔悴损，如今有谁堪摘？守着窗儿，独自怎生得黑！梧桐更兼细雨，到黄昏、点点滴滴。这次第，怎一个愁字了得！ 怎一个愁字了得啊！","categories":[{"name":"杂记","slug":"杂记","permalink":"https://lokya.github.io/categories/杂记/"}],"tags":[{"name":"杂记","slug":"杂记","permalink":"https://lokya.github.io/tags/杂记/"}]},{"title":"论部门研发项目之怪现状","slug":"others/miscellany_1","date":"2019-05-07T14:53:51.127Z","updated":"2019-05-09T15:03:52.252Z","comments":true,"path":"2019/05/07/others/miscellany_1/","link":"","permalink":"https://lokya.github.io/2019/05/07/others/miscellany_1/","excerpt":"新产品开发已一年有余，每思项目中之事，无不发现其怪。此怪异有能者不作为，无能者空哀怨。。。。","text":"新产品开发已一年有余，每思项目中之事，无不发现其怪。此怪异有能者不作为，无能者空哀怨。。。。 怪现状一、从九干到九，天长又地久上班时间必须是早上9点上班到晚上9点下班，即使晚上没有什么工作内容。也必须坐到9点。9点已经变成一个闹钟，一个节点，甚至一个屏障。。。 怪现状二、早走你就走，好评我没有每次上班，拥有一种上学的感觉，不到点不能下课放学。只要有人早走，领导就会给黑脸看，评价降低，甚至增加工作量，强行加大开发时间。 怪现状三、苦劳别埋怨，不是我心愿总有同事开玩笑说加班累，周末没有时间。领导说又不是我让你待到9点后或者周末加班的，这是你自愿的。。。。 怪现状四、时间很不够，敏捷拿来凑每次定开发时间，都是直接上层拍板定时间。对项目的开发时间和测试发布时间不能很好的估计和评测，时间很紧。产品设计后开发的时间更加紧张，领导称之为敏捷开发模式。。。 怪现状五、需求天天改，结局没人采每次需求都各种变动，多个领导，多个产品。从不同角度不同思维进行修改，最终做出个什么样子后，没人再过问，都点头说ok。 怪现状六、技术常常换，项目玩不转项目人员不固定，今天来一个，明天撤项一个。代码把控一般，bug一堆，问题一堆。如何完好运行项目。","categories":[{"name":"杂记","slug":"杂记","permalink":"https://lokya.github.io/categories/杂记/"}],"tags":[{"name":"杂记","slug":"杂记","permalink":"https://lokya.github.io/tags/杂记/"}]},{"title":"个人摄影 - 第一期","slug":"shoot/shoot_1","date":"2019-05-06T09:16:38.802Z","updated":"2019-05-06T15:09:02.124Z","comments":true,"path":"2019/05/06/shoot/shoot_1/","link":"","permalink":"https://lokya.github.io/2019/05/06/shoot/shoot_1/","excerpt":"","text":"介绍 拍摄时间 - 2018年05月19日 地点 - 公司旁小路 闲谈天色阴暗，雨势渐小。雨珠在花和叶上欢乐的跳动。从叫做叶的平台跳下，落在地上，渗进土里。梦着下次和花的轮回。 备注图片是我自己拍的，如果要转发和使用，请打声招呼，或者注明出处。 请勿私自盗用，谢谢","categories":[{"name":"拍照摄影","slug":"拍照摄影","permalink":"https://lokya.github.io/categories/拍照摄影/"}],"tags":[{"name":"拍照摄影","slug":"拍照摄影","permalink":"https://lokya.github.io/tags/拍照摄影/"}]},{"title":"ES6-变量","slug":"knowledge/es6/lesson_1","date":"2019-05-06T08:50:20.293Z","updated":"2019-05-07T08:55:30.512Z","comments":true,"path":"2019/05/06/knowledge/es6/lesson_1/","link":"","permalink":"https://lokya.github.io/2019/05/06/knowledge/es6/lesson_1/","excerpt":"","text":"let 和 constlet声明变量，类似于var，但是let有作用域的概念。const 声明常量，一旦声明后，不可改变。const 声明后要立马初始化。 作用域 作用域顾名思义就是只有在某个区域内起作用。let 就只能在其作用域中起作用。 1234567&#123; let a = 10; var b = 1;&#125;a // ReferenceError: a is not defined.b // 1 变量提升 var 命令会发生“变量提升”现象，即变量可以在声明之前使用，值为undefined。 let 定义的变量如果在声明之前使用会报错。 暂时性死区 如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域（暂时性死区）。凡是在声明之前就使用这些变量，就会报错。 重复声明 let不允许在相同作用域内，重复声明同一个变量。 const本质 const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。 对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。 global对象顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。 ES5 之中，顶层对象的属性与全局变量是等价的。12345window.a = 1;a // 1a = 2;window.a // 2 为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性； let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性","categories":[{"name":"javascript","slug":"javascript","permalink":"https://lokya.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://lokya.github.io/tags/javascript/"},{"name":"ES6","slug":"ES6","permalink":"https://lokya.github.io/tags/ES6/"}]},{"title":"源","slug":"others/start","date":"2019-04-30T01:51:02.269Z","updated":"2019-05-06T15:09:08.465Z","comments":true,"path":"2019/04/30/others/start/","link":"","permalink":"https://lokya.github.io/2019/04/30/others/start/","excerpt":"","text":"原因我一直是一个不太喜欢写博客和文章的人，从业这么久，不喜欢去csdn或者博客园去发布文章。总觉得有时间还是看看书，娱乐娱乐比较好。忽然觉得有一个属于自己的地方，发点自己想想写的挺不错的。 打算想利用这个博客写点自己的东西，不论是技术分享还是技术笔记，或者生活杂记，都记录下来。例如拍个照片，可以发上来，这是一种记忆。 Emmmm其实也不知道说什么好，总之，希望利用好这个博客吧。","categories":[{"name":"杂记","slug":"杂记","permalink":"https://lokya.github.io/categories/杂记/"}],"tags":[]}]}