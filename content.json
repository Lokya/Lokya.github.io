{"meta":{"title":"Lokya","subtitle":"Lokya‘s blog","description":"lokya lokya blog","author":"Lokya","url":"https://lokya.github.io","root":"/"},"pages":[{"title":"简介","date":"2019-05-06T08:42:12.708Z","updated":"2019-05-06T08:42:12.708Z","comments":true,"path":"about/index.html","permalink":"https://lokya.github.io/about/index.html","excerpt":"","text":"I am lokya我欲乘风归去，又恐琼楼玉宇，高处不胜寒，起舞弄清影，何似在人间。。。。。。 先写这么多吧。。。。。"},{"title":"","date":"2019-05-03T02:06:32.254Z","updated":"2019-05-03T02:06:32.254Z","comments":true,"path":"mylist/index.html","permalink":"https://lokya.github.io/mylist/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2019-05-05T15:13:20.494Z","updated":"2019-05-05T15:13:20.494Z","comments":true,"path":"blog/categories/index.html","permalink":"https://lokya.github.io/blog/categories/index.html","excerpt":"","text":""},{"title":"归档","date":"2019-05-06T03:17:19.125Z","updated":"2019-05-06T03:17:19.125Z","comments":true,"path":"blog/archives/index.html","permalink":"https://lokya.github.io/blog/archives/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2019-05-07T01:28:53.737Z","updated":"2019-05-07T01:28:53.737Z","comments":true,"path":"blog/tags/index.html","permalink":"https://lokya.github.io/blog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"git submodule foreach 忽略子模块","slug":"knowledge/git/submoduleForeach","date":"2020-05-31T03:21:09.462Z","updated":"2020-05-31T03:23:01.434Z","comments":true,"path":"2020/05/31/knowledge/git/submoduleForeach/","link":"","permalink":"https://lokya.github.io/2020/05/31/knowledge/git/submoduleForeach/","excerpt":"","text":"git submodule foreach 忽略子模块背景我们公司的项目是采用 lerna 进行管理的，主模块下面的每个模块都是由不同的开发团队进行开发的，存储在不同的 git 仓库，在每次大版本进行发布的时候，需要批量对所有模块进行操作，例如历史分支代码 tag保留，删除迭代分支，创建新的分支等。但是项目在不同的迭代周期中会有新的模块临时添加进来，新的模块并没有创建和其他分支一样的迭代周期分支，在发版期间批量处理时，在每个模块下执行一些 git 命令会报错，导致执行中断。 git submodule foreachgit submodulegit 子模块的用法，我就不多废话了，好多人都用过了，如果没有用过和了解过的朋友，可以参考官网文档： git 子模块 git submodule foreach简单来说 git submodule foreach 它能在每一个子模块中运行任意命令 基本使用比如，我们希望所有的子模块都切换到 develop 分支 1git submodule foreach git checkout develop 再比如 ，我们希望拉取所有子模块的代码 1git submodule foreach git pull 不报错退出的执行但是 foreach 是遍历所有的子模块，我们要在所有的子模块下进行执行，势必会有场景中提到的报错情况，于是我去查看了官方文档: git-submodule 官方给了一种解决方案，可以解决 git 在子模块中执行报错后直接退出，而是继续执行。 1git submodule foreach '其他命令 || :' 任何子模块中命令的非零返回都会导致处理终止 其实我们还可以这样： 1git submodule foreach '其他命令 || true' 选择跳过现在我们已经实现了执行命令后不报错退出，但是还没解决可以自主选择某几个子模块不执行/执行我们的命令，想想这样一个场景，我们需要在某个命名为 release-bak 的分支上面打个 tag 对分支进行保存，但是现在某个子模块的分支上没有 release-bak 这个分支，在批量执行 git tag xxx 的时候，由于不报错，所有的模块都会执行，但是没有 release-bak 分支的这个模块打的 tag 不是我们预期的，这种情况如何处理呢？ 其实官网也给了我们解决方式，让我们看下 git foreach 的说明 我们再回忆下解释： git submodule foreach 它能在每一个子模块中运行任意命令 那么是否我们可以在 git submodule foreach 后面执行任何 bash 命令呢？ 于是我在 git submodule foreach 后面写了一个 cash 语句来进行执行: 1git submodule foreach 'case $name in a-Module|b-Module|c-Module) ;; *) git status ;; esac' 这个命令是去批量执行，如果遇到 a-Module，b-Module，c-Module 中的任何一个，什么都不操作，其他的子模块中，执行 git status。测试后，的确可以跳过 a-Module|b-Module|c-Module 这三个模块进行处理。 那么了解这个特性后，我们就彻底解放天性，可以随心的去通过条件控制我们 执行或者不执行 的各种情况。 其他其实 git 拥有很多特性，好多我们都没学习过、使用过，还是需要多积累和学习，在这里祝各位 0 error, 0 bug","categories":[{"name":"Git","slug":"Git","permalink":"https://lokya.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://lokya.github.io/tags/Git/"}]},{"title":"package.json resolutions 深入浅出","slug":"knowledge/yarn/resolutions","date":"2020-04-10T14:26:21.203Z","updated":"2020-04-12T03:47:03.742Z","comments":true,"path":"2020/04/10/knowledge/yarn/resolutions/","link":"","permalink":"https://lokya.github.io/2020/04/10/knowledge/yarn/resolutions/","excerpt":"","text":"package.json resolutions 深入浅出基本使用yarn install --flat 命令将会自动在 package.json 文件里加入 resolutions 字段或者直接在 package.json 中增加字段配置 12345&#123; \"resolutions\": &#123; \"package-1\": \"0.0.1\" &#125;&#125; resolutions 字段允许再依赖关系中定义自定义软件包版本。 使用场景 项目中可能依赖于不经常更新的软件包，但这个依赖包依赖于另一个进行了重要升级的软件包。在这种情况下，如果直接依赖项指定的版本范围不包含新的子依赖项版本，只能等中间包的作者进行优化修改。 项目的子依赖项获得了重要的安全更新，并不希望等待直接依赖项发布最低版本更新。 依赖一个无人维护，但工作包和其中一个依赖项得到升级。 依赖性定义了一个广泛的版本范围，并且您的子依赖关系刚刚得到了一个有问题的更新，因此您希望将其固定到较早的版本。 官方示例package.json 1234567&quot;dependencies&quot;: &#123; &quot;package-a&quot;: &quot;1.0.0&quot;, &quot;package-b&quot;: &quot;1.0.0&quot; &#125;,&quot;resolutions&quot;: &#123;&quot;**/package-d1&quot;: &quot;2.0.0&quot;&#125; 依赖图 12345678910111213141516package-a@1.0.0 |_ package-d1@1.0.0 |_ package-d2@1.0.0package-a@2.0.0 |_ package-d1@2.0.0 |_ package-d2@1.0.0package-b@1.0.0 |_ package-d1@2.0.0 |_ package-d2@1.0.0package-c@1.0.0 |_ package-a@2.0.0 |_ package-d1@2.0.0 |_ package-d2@1.0.0 resolutions 和其他依赖关系devDependencies optionalDependencies 和依赖关系字段总是优先于 resolutions :如果用户定义显式的依赖,这意味着他希望这个版本,即使是指定不明确的规范。 项目和项目依赖的包同时具有 resolutions 字段在我们的项目中，我们同时维护项目和项目中依赖的包，而且在项目和我们所依赖的包中，同时对同一个第三方包进行 resolutions 版本规范，会是什么样子呢？ 首先，我在子包中，将 choerodon-ui 的版本规范为0.8.58 然后它的 lock 版本为： 发布 npm 包后，将这个 srm-front-boot 依赖进主项目 没有加 resolutions 之前，lock 文件的版本是这样的： 然后在 devDependencies 中增加 choerodon-ui 的依赖，发现会依赖成两个版本 总结： 由上面的情况我们可以得出，子模块中的 resolutions 自会限制子模块中某个依赖的版本，如果在父工程项目中也同时需要对某个包进行版本规范，需要在父工程中也添加 resolutions 对版本进行规范，父项目和子依赖包中的 resolutions 字段不会进行冲突。","categories":[{"name":"Yarn","slug":"Yarn","permalink":"https://lokya.github.io/categories/Yarn/"}],"tags":[{"name":"Yarn","slug":"Yarn","permalink":"https://lokya.github.io/tags/Yarn/"}]},{"title":"npm config 优先级","slug":"knowledge/npm/npmPriority","date":"2020-03-26T02:29:33.075Z","updated":"2020-03-26T02:38:10.954Z","comments":true,"path":"2020/03/26/knowledge/npm/npmPriority/","link":"","permalink":"https://lokya.github.io/2020/03/26/knowledge/npm/npmPriority/","excerpt":"","text":"NPM config 优先级npm 在读取配置的时候会按照优先级进行读取，然后以高优先级的配置进行处理. 优先级npm 的优先级如下，优先级从高到低 1、命令行 1npm config set registry http://registry.npmjs.org 2、环境变量 以 npm_config_ 为前缀的环境变量会被识别为 npm 的配置属性。 npm_config_proxy=http://xxxx.com 3、工程的 .npmrc 文件 存在于开发工程根目录下的 .npmrc 配置文件 4、用户 .npmrc 文件 存在于用户根目录下的 .npmrc 文件。 5、全局 .npmrc 文件 存在于 node 全局的 .npmrc 文件。 6、npm 内置的 .npmrc 文件 存在于 npm 包的内置 .npmrc 文件/path/to/npm/.npmrc。 7、npm 的默认配置 npm 本身有默认配置。对于以上情况下都没有设置的配置，npm 会使用默认配置","categories":[{"name":"npm","slug":"npm","permalink":"https://lokya.github.io/categories/npm/"}],"tags":[{"name":"NPM","slug":"NPM","permalink":"https://lokya.github.io/tags/NPM/"}]},{"title":"filter - 网页灰色效果","slug":"knowledge/css/css1","date":"2019-12-13T07:27:22.041Z","updated":"2019-12-13T07:30:32.089Z","comments":true,"path":"2019/12/13/knowledge/css/css1/","link":"","permalink":"https://lokya.github.io/2019/12/13/knowledge/css/css1/","excerpt":"","text":"网页灰色效果百度百科在有人去世会把搜索信息页面灰化，今天访问b站的时候发现在公祭日这一天b站也全站灰化，各网站都以一种互联网的风格来哀悼死者。 哀悼的同时给大家顺便讲下全网站灰色化的实现。 filter(滤镜)用法：filter: none | blur() | brightness() | contrast() | drop-shadow() | grayscale() | hue-rotate() | invert() | opacity() | saturate() | sepia() | url(); 说明： none: 默认值。 blur(): 给图像设置高斯模糊。 brightness(): 给图片应用一种线性乘法，使其看起来更亮或更暗。 contrast(): 调整图像的对比度。 drop-shadow(): 给图像设置一个阴影效果 grayscale(): 将图像转换为灰度图像。 hue-rotate(): 给图像应用色相旋转。 invert(): 反转输入图像。 opacity(): 转化图像的透明程度。 saturate(): 转换图像饱和度。 sepia(): 将图像转换为深褐色。 url(): URL函数接受一个XML文件，该文件设置了一个SVG滤镜，且可以包含一个锚点来指定一个具体的滤镜元素。 兼容性 网站灰色实现使用 grayscale 来实现效果。可以设置 grayscale(100%); 来图像转换为灰度图像。 1234567html &#123; filter: grayscale(100%); -webkit-filter: grayscale(100%); -moz-filter: grayscale(100%); -ms-filter: grayscale(100%); -o-filter: grayscale(100%);&#125; 展示效果对比正常页面 灰色化后页面 图片也可以单独给图片设置灰色效果 1234567img &#123; filter: grayscale(100%); -webkit-filter: grayscale(100%); -moz-filter: grayscale(100%); -ms-filter: grayscale(100%); -o-filter: grayscale(100%);&#125; 最后其他效果大家也可以尝试下，会有意想不到的效果。。。。","categories":[{"name":"CSS","slug":"CSS","permalink":"https://lokya.github.io/categories/CSS/"}],"tags":[{"name":"CSS3","slug":"CSS3","permalink":"https://lokya.github.io/tags/CSS3/"}]},{"title":"Xcode 报错解决记录","slug":"knowledge/reactNative/react_native_1","date":"2019-11-12T07:31:00.276Z","updated":"2019-11-12T08:09:51.028Z","comments":true,"path":"2019/11/12/knowledge/reactNative/react_native_1/","link":"","permalink":"https://lokya.github.io/2019/11/12/knowledge/reactNative/react_native_1/","excerpt":"","text":"Xcode: library not found for -l xxxx 报错问题定位最近在进行 react native 的学习和使用，在使用 Xcode 进行打包的时候，经常会看见 library not found for -lxxx 的这种报错。结合网络上给的资料和自己的一些分析，做一个记录吧。 问题分析这个问题其实就是第三方库没有加载到导致的保存。 问题处理pod 安装包IOS 的环境有一部分人是使用 cocoapods 来进行包管理的，所以可以怀疑是第三方库没有安装。 在 ios 文件夹下执行以下语句 123pod deintegrate pod instll 一般会解决大部分问题 添加搜索路径Xcode &gt; Target &gt; Build Settings &gt; 搜索 Library Search Path 在里面添加第三方库的路径 文件目录变动有可能项目中的一些静态文件位置移动，毕竟项目是由多人开发的 Xcode &gt; Target &gt; Build Phases &gt; Link binary With Libraries 然后查看引入的文件，是否有红色提示，如果是红色的话说明这个文件位置进行的变动，现在找不到。 可以在选中红色文件右键 Reveal in Project Navigator 然后定位一下，或者手动去寻找文件位置。重新引入即可。 项目部分文件被篡改这种问题就比较恶心了，有可能其他人在操作项目的时候执行了一些命令，撤销的时候有文件残留导致的或者引起了一些路径变化不可逆。 如果可以使用 git 的话，查看文件变动，还原后再调试启动，定位解决。 推荐以上3中方法不可以解决问题的话，重新创建项目，然后一步一步迁移原工程代码中进行进行测试，当然这个是最傻最笨的办法。 其他Xcode 的坑有时候还是蛮多的，后续还会再开一个文档写Xcode的一些常见问题的解决。。。。","categories":[{"name":"react-native","slug":"react-native","permalink":"https://lokya.github.io/categories/react-native/"}],"tags":[{"name":"react-native","slug":"react-native","permalink":"https://lokya.github.io/tags/react-native/"}]},{"title":"node is incompatible with this module","slug":"notes/note2","date":"2019-10-28T03:21:13.477Z","updated":"2019-10-28T03:47:27.236Z","comments":true,"path":"2019/10/28/notes/note2/","link":"","permalink":"https://lokya.github.io/2019/10/28/notes/note2/","excerpt":"","text":"“node” is incompatible with this module背景今天在执行 yarn 进行安装的时候，服务器报错 error file-loader@2.0.0: The engine &quot;node&quot; is incompatible with this module. Expected version &quot;&gt;= 6.0.0 一开始以为是 node 版本问题，但是执行 node -v 后发现 node 版本是 v8.12.0, 版本完全大于 6.0.0 查询后需要忽略 yarn 的引擎检查 执行 12345&gt; yarn config set ignore-engines true#或者&gt; yarn --ignore-engines 即可执行成功。 备注在这里再添加点 yarn 官网的一些操作 yarn install用于安装一个项目的所有依赖。 这个命令最常见的使用场景是在你刚Check out一份项目代码之后，或者在你需要使用其他开发者新增加的项目依赖的时候。 如果习惯使用 npm ， 你可能希望使用--save 或 --save-dev， 这些已经被 yarn add 和 yarn add --dev 所取代。 执行不带任何命令的 yarn，等同于执行yarn install，并透传所有参数。 如果需要可重现的依赖环境（比如在持续集成系统中），应该传入 --frozen-lockfile 标志。 yarn install在本地 node_modules 目录安装 package.json 里列出的所有依赖。 yarn install –check-files验证 node_modules 中已安装的文件没有被移除。 yarn install –flat安装所有依赖，但每个依赖只允许有一个版本存在。 第一次运行这个命令时，会提示你在每个依赖包的多个版本范围中选择一个版本。 这会被添加到你的 package.json 文件的 resolutions 字段。 12345\"resolutions\": &#123; \"package-a\": \"2.0.0\", \"package-b\": \"5.0.0\", \"package-c\": \"1.5.2\"&#125; yarn install –force这回重新拉取所有包，即使之前已经安装的。 yarn install –har从安装期间的所有网络请求输出一个 HTTP archive。 HAR 文件通常用于排查网络性能，并能用 Google’s HAR Analyzer 或 HAR Viewer 这样的工具分析。 yarn install –ignore-scripts不执行项目 package.json 及其依赖定义的任何脚本。 yarn install –modules-folder 为 node_modules 目录指定另一位置，代替默认的 ./node_modules。 yarn install –no-lockfile不读取或生成 yarn.lock 锁文件。 yarn install –production[=true|false]如果 NODE_ENV 环境变量设为 production，Yarn 将不安装任何列于 devDependencies 的包。 使用此标志指示 Yarn 忽略 NODE_ENV 并用它取代“生产”与否的状态。 注意： --production 等同 --production=true。--prod 是 --production 的别名。 yarn install –pure-lockfile不生成 yarn.lock 锁文件。 yarn install –frozen-lockfile不生成 yarn.lock 锁文件，并且，如果需要更新则会报错。 yarn install –silent执行 yarn install 而不显示安装日志 yarn install –ignore-engines忽略引擎检查。 yarn install –ignore-optional不安装可选依赖。 yarn install –offline运行 yarn install 于离线模式。 yarn install –non-interactive禁用询问交互，比如当没有合适版本的依赖时 yarn install –update-checksums当跟对应包的校验和不一致时， 更新 yarn.lock 锁文件的校验和","categories":[{"name":"node","slug":"node","permalink":"https://lokya.github.io/categories/node/"}],"tags":[{"name":"note","slug":"note","permalink":"https://lokya.github.io/tags/note/"},{"name":"node","slug":"node","permalink":"https://lokya.github.io/tags/node/"}]},{"title":"Git 子模块","slug":"knowledge/git/gitSubmodle","date":"2019-08-26T07:57:12.780Z","updated":"2019-08-28T11:40:33.384Z","comments":true,"path":"2019/08/26/knowledge/git/gitSubmodle/","link":"","permalink":"https://lokya.github.io/2019/08/26/knowledge/git/gitSubmodle/","excerpt":"","text":"Git 子模块介绍git子模块，即 git submodule, 是一种在一个 git 仓库中嵌套另外一个 git 仓库代码的实现方式。 有时候我们需要将一些代码放到一个仓库中，由其他人进行开发和维护，而在另外一个项目中，只需要引入这个仓库中的代码，并不对代码进行修改这种情形。我们就可以使用 git submodule 来实现。 形象一点说明：我要搭建一个博客，博客的结构如下 blog ├── content ├── index.html ├── public ├── theme └── conf文件 里面的 theme 文件夹内容是我的博客主题，可以自己手动去写，也可以找好看的主题进行魔改。但是在魔改后我又想提交到自己的仓库进行存储。这种时候可以把 theme 文件夹下面的代码放到一个 git 仓库中。然后整个博客工程放到一个 git 仓库中。 使用 git submodule 结合起来。 使用添加子模块的使用很简单，拿到子模块的 git 仓库地址。在项目的根文件夹下执行添加 git submodule 命令。 1&gt; git submodule add -b develop https://code.xxxxxx.com.cn/lokya-theme.git theme/lokya-theme 解释下上面的命令，上面的命令是个组合命令，实现的效果是给当前项目添加子模块，添加的是子模块的 develop 分支，将代码放到 theme 文件夹下，名称为 lokya-theme。 git submodule add https://code.xxxxxx.com.cn/lokya-theme.git 添加仓库 git submodule add -b develop https://code.xxxxxx.com.cn/lokya-theme.git 添加仓库的 develop 代码 git submodule add https://code.xxxxxx.com.cn/lokya-theme.git theme/lokya-theme 将代码放到theme文件夹中，命名为 lokya-theme 这样就把子模块添加进去了。 初始化子模块的初始化可以使用一下命令，也可直接组合使用 123&gt; git clone &lt;repository&gt; --recursive 递归的方式克隆整个项目&gt; git submodule init 初始化子模块&gt; git submodule update 更新子模块 组合使用 1&gt; git submodule update --init --recursive 多个子模块使用可以使用多个子模块，使用 git submodule add 添加多个 git 子模块 统一操作子模块可以使用 git submodule foreach 来进行批量操作子模块，比如所有子模块切换分支和拉取代码 12&gt; git submodule foreach git checkout develop&gt; git submodule foreach git pull 踩坑记录问题描述在多个子模块进行 docker 打镜像的时候，初始化仓库拉取不到代码。 由于在 runner 中设置不了 git 仓库的账号密码，拉取不到。 问题解决由于我这边子模块和主工程的仓库在同一个账号下，于是修改 .gitmodules 文件 1234[submodule &quot;theme/lokya-theme&quot;] path = theme/lokya-theme url = https://code.xxxxxx.com.cn/lokya-theme.git branch = develop 修改为 1234[submodule &quot;theme/lokya-theme&quot;] path = theme/lokya-theme url = ../../lokya-theme.git branch = develop 通过相对路径去获取 git 仓库，这样可以默认使用同一套账号密码，子模块也可以进行代码拉取。 反思总结git submodule 是一种很好的解决多个库拆分、组合的方式，可以完全避免代码冲突，多人权限维护等。 但是 git submodule 的使用时候要注意每次切换分支都会将子模块的提交指向游离态，需要手动去切换分支拉取最新的子模块代码。","categories":[{"name":"Git","slug":"Git","permalink":"https://lokya.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://lokya.github.io/tags/Git/"}]},{"title":"前端项目拆库","slug":"knowledge/git/gitRepoSplit","date":"2019-08-26T07:56:20.831Z","updated":"2019-08-26T11:17:40.799Z","comments":true,"path":"2019/08/26/knowledge/git/gitRepoSplit/","link":"","permalink":"https://lokya.github.io/2019/08/26/knowledge/git/gitRepoSplit/","excerpt":"","text":"前端代码拆库背景Monorepo 和 MultirepoMonorepo Monorepo 是管理项目代码的一个方式，指在一个项目仓库 (repo) 中管理多个模块/包 (package)，不同于常见的每个模块建一个 repo。而 lerna 是 Monorepo 目前最好的一种解决方案，通过 lerna 的一些命令，例如 lerna run xxx 可以统一对各个模块进行操作。 Multirepo Multirepo 从字面意思上来说就是多个 repo ，每个模块或者项目创建各自的仓库，单独开发维护，相互之间调用只能以npm包的形式或者使用 git 子模块。 我们的项目之前是基于 monorepo 形式创建的，即多个子工程在一个项目中管理，然后使用 lerna 管理工具，统一对 packages 文件夹下面的子模块进行管理。 由于项目前后端分离、前端工程和后端工程版本要保持对应一致、要部署到多个不同的环境、同时我们又要引入其他部门的基础服务代码，这一系列的要求就导致项目使用monorepo的模式进行不下去。 举个例子 开发环境和测试环境配置不相同。 测试环境中的基础服务包版本和开发环境中版本不一致，即在 develop 环境，使用的某个基础服务包版本为 1.1.9， test 环境使用的版本是1.0.9，因为两个环境的后端版本不相同，前端也要保持统一。 开发在各自模块下进行开发，每个团队要在自己组所属模块下面开发，不方便区分哪些代码进行开发，哪些代码进行提测。 基于以上情况，这边对代码进行拆分。 仓库、分支介绍将代码拆分成以下几种 git 仓库 front-code: 前端纯净仓库，不包含任何业务代码，所有新模块都基于此代码进行初始化。 front-[模块缩写]: 各个子模块的工程，只包含每个模块的功能代码。 front-boot: 前端基础模块仓库，项目所需要的一些公共组件，方法，基础引用都在此模块中，每个子模块都要引入的模块。 front-core: 前端框架仓库，前端测试环境，开发环境，发布环境都基于此仓库进行部署。 原本项目中没有boot这个模块，综合考虑下来，应该建立一个公共模块，让所有的子模块都依赖，并且将公共内容放到这个模块中，之后对于公共内容的新增、修改都只需要改动这一个模块，然后发布 npm包 ，小版本直接升级依赖即可, boot 这个模块要引入到各个模块的 devDependencies 中，可以防止重复打包. 顺便拆了个纯净仓库，项目以后的开发会有其他项目，可以直接基于这个项目工程拿取代码进行开发，基本的配置都配置完成。‘ front-core 这个仓库 分成 master test develop 这几个分支，其中 master 分支为正式环境发布分支，没有任何业务代码，全部引入的是文档打版的 npm包。 test 分支为测试环境的发布分支，使用 git子模块 将各个子模块的 test 分支代码进行引入。 develop 分支为开发环境的发布分支，同样使用 git子模块 将各个子模块的 develop 分支代码进行引入。 front-[模块缩写]这种命名的仓库就分配到各个组，由各个组创建 develop 和 test 分支进行开发，完全解决组之间代码冲突的问题。 优缺点优点 各组负责自己模块，避免组间冲突，同时减轻前端管理组的压力。 可针对各种前端发布条件进行修改，各组、依赖模块、基础模块等都完全区分开，不相互影响。 前端启动项目所消耗时间减少，提升开发效率。 公共模块提取了代码，减少冗余代码，项目更清晰简洁。 缺点 各组人员的 git 水准参差不齐， 对各组负责人来说压力增大。 组件模块相互依赖，需要实时沟通，一旦版本不统一，最终会出现多版本打包。 知识点 Monorepo Multirepo Git Submodule Git Flow devDependencies 和 dependencies 的区别 总结整个拆库从构思到测试、建库、正式发布、讲解持续了近2周。只要思路通了，整个模式都玩的通，剩下的就是完善模块，让模块更纯粹和简洁。 后续还准备将 front-code 做成脚手架，使用脚手架创建项目，将一些简单的命令集成进来，使得管理方便。","categories":[{"name":"Git","slug":"Git","permalink":"https://lokya.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://lokya.github.io/tags/Git/"}]},{"title":"Git 不能推送远程分支","slug":"knowledge/git/gitTips1","date":"2019-08-07T11:02:17.147Z","updated":"2019-08-07T11:34:58.202Z","comments":true,"path":"2019/08/07/knowledge/git/gitTips1/","link":"","permalink":"https://lokya.github.io/2019/08/07/knowledge/git/gitTips1/","excerpt":"","text":"dst refspec XXX matches more than one场景项目中有个分支是 1.1.0 分支，用来进行升级和版本代码保留，这个分支最近被某个坑货给玩坏了，发现我本地的代码是完整保留的，于是要将代码推送到远程。 问题我在执行下面的代码之后 1git push origin --delete 1.1.0 报错提示： dst refspec XXX matches more than one 意思大概是具体的引用匹配到的不止一个。 查询相关资料发现，不推荐分支和 tag 名字完全一样。。。 当远程仓库同时存在相同名称的 branch 和 tag 时，不指明绝对路径的前提下，操作这个名称的 branch 和 tag 都会出现这个问题。 解决我在项目中去搜索发现同样命名为 1.1.0的branch和命名为 1.1.0的 tag ，于是在删除远程分支的时候，搜索到的匹配就不只一个。 解决方法1、删除 检出 tag,然后进行重命名或者基于它新建 tag 。 然后再通过命令去删除远程分支。 推送tag到远程 2、使用绝对路径 直接指明绝对路径 1$ git push origin :refs/heads/1.1.0 如果是推代码带tag 1$ git push origin :refs/tags/1.1.0 结论我比较推荐使用第二种方法，当然这次的做法可以直接去仓库进行手动分支删除，一切可视化操作，但是使用命令去实现更能了解一些git的知识。","categories":[{"name":"Git","slug":"Git","permalink":"https://lokya.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://lokya.github.io/tags/Git/"}]},{"title":"前端版本控制","slug":"knowledge/git/versionControl","date":"2019-08-05T11:23:02.976Z","updated":"2019-08-05T11:31:00.803Z","comments":true,"path":"2019/08/05/knowledge/git/versionControl/","link":"","permalink":"https://lokya.github.io/2019/08/05/knowledge/git/versionControl/","excerpt":"","text":"前端版本控制背景公司代码采用 monorepo 模式，在 package 文件夹下管理各个模块，整个项目采用 lerna 进行管理。 最近项目也到稳定期，需要进行发版和发布，对于项目来说，直接使用某一个版本的npm包即可，于是要制定一个版本控制的规范。 公司的发布源设置为私有源，但是想了想这个方式同样适用于 npm 公有源。 前言 使用语义化版本控制(Semantic Versioning)，你必须先有定义好的公共 API 。这可以透过文件定义或代码强制要求来实现(API 文档)。无论如何，这套 API 的清楚明了是十分重要的。一旦你定义了公共 API，你就可以透过修改相应的版本号来向大家说明你的修改。考虑使用这样的版本号格式：X.Y.Z （主版本号.次版本号.修订号），先行版本号及版本编译信息可以加到“主版本号.次版本号.修订号”的后面，作为延伸。 版本号递增规则 主版本号：当你做了不兼容的 API 修改，递增主版本号 次版本号：当你做了向下兼容的功能性新，递增次版本号 修订号：当你做了向下兼容的问题修正，递增修订号 语义化版本控制规范 使用语义化版本控制的软件必须定义公共 API。该 API 可以在代码中被定义或出现于严谨的文件内。无论何种形式都应该力求精确且完整。 标准的版本号必须采用 X.Y.Z 的格式，其中 X、Y 和 Z 为非负的整数，且禁止在数字前方补零。X 是主版本号、Y 是次版本号、而 Z 为修订号。每个元素必须以数值来递增。例如：1.9.1 -&gt; 1.10.0 -&gt; 1.11.0。 标记版本号的软件发行后，禁止改变该版本软件的内容。任何修改都必须以新版本发行。 主版本号为零（0.y.z）的软件处于开发初始阶段，一切都可能随时被改变。这样的公共 API 不应该被视为稳定版。以 0.1.0 作为你的初始化开发版本，并在后续的每次发行时递增次版本号 1.0.0 的版本号用于界定公共 API 的形成。这一版本之后所有的版本号更新都基于公共 API 及其修改内容。当你的软件被用于正式环境，它应该已经达到了 1.0.0 版。 修订号 Z（x.y.Z | x &gt; 0）必须在只做了向下兼容的修正时才递增。这里的修正指的是针对不正确结果而进行的内部修改。 次版本号 Y（x.Y.z | x &gt; 0）必须在有向下兼容的新功能出现时递增。在任何公共 API 的功能被标记为弃用时也必须递增。也可以在内部程序有大量新功能或改进被加入时递增，其中可以包括修订级别的改变。每当次版本号递增时，修订号必须归零。 主版本号 X（X.y.z | X &gt; 0）必须在有任何不兼容的修改被加入公共 API 时递增。其中可以包括次版本号及修订级别的改变。每当主版本号递增时，次版本号和修订号必须归零。 先行版本号可以被标注在修订版之后，先加上一个连接号再加上一连串以句点分隔的标识符号来修饰。标识符号必须由 ASCII 码的英数字和连接号 [0-9A-Za-z-] 组成，且禁止留白。数字型的标识符号禁止在前方补零。先行版的优先级低于相关联的标准版本。被标上先行版本号则表示这个版本并非稳定而且可能无法达到兼容的需求。范例：1.0.0-alpha、1.0.0-alpha.1、1.0.0-0.3.7、1.0.0-x.7.z.92。 版本编译信息可以被标注在修订版或先行版本号之后，先加上一个加号再加上一连串以句点分隔的标识符号来修饰。标识符号必须由 ASCII 的英数字和连接号 [0-9A-Za-z-] 组成，且禁止留白。当判断版本的优先层级时，版本编译信息可被忽略。因此当两个版本只有在版本编译信息有差别时，属于相同的优先层级。范例：1.0.0-alpha+001、1.0.0+20130313144700、1.0.0-beta+exp.sha.5114f85。 版本的优先层级指的是不同版本在排序时如何比较。判断优先层级时，必须把版本依序拆分为主版本号、次版本号、修订号及先行版本号后进行比较。由左到右依序比较每个标识符号，第一个差异值用来决定优先层级：主版本号、次版本号及修订号以数值比较，例如：1.0.0 &lt; 2.0.0 &lt; 2.1.0 &lt; 2.1.1。当主版本号、次版本号及修订号都相同时，改以优先层级比较低的先行版本号决定。例如：1.0.0-alpha &lt; 1.0.0。有相同主版本号、次版本号及修订号的两个先行版本号，其优先层级必须透过由左到右的每个被句点分隔的标识符号来比较，直到找到一个差异值后决定：只有数字的标识符号以数值高低比较，有字母或连接号时则逐字以 ASCII 的排序来比较。数字的标识符号比非数字的标识符号优先层级低。若开头的标识符号都相同时，栏位比较多的先行版本号优先层级比较高。范例：1.0.0-alpha &lt; 1.0.0-alpha.1 &lt; 1.0.0-alpha.beta &lt; 1.0.0-beta &lt; 1.0.0-beta.2 &lt; 1.0.0-beta.11 &lt; 1.0.0- rc.1 &lt; 1.0.0。 版本号信息 alpha：内部测试版。α是希腊字母的第一个，表示最早的版本，一般用户不要下载这个版本，这个版本包含很多BUG，功能也不全，主要是给开发人员和测试人员测试和找BUG用的。 beta：公开测试版。β是希腊字母的第二个，顾名思义，这个版本比alpha版发布得晚一些，主要是给“部落”用户和忠实用户测试用的，该版本任然存在很多BUG，但是相对alpha版要稳定一些。这个阶段版本的软件还会不断增加新功能。如果你是发烧友，可以下载这个版本。 RC(Release Candidate)：候选版本。该版本又较beta版更进一步了，该版本功能不再增加，和最终发布版功能一样。这个版本有点像最终发行版之前的一个类似预览版，这个的发布就标明离最终发行版不远了。作为普通用户，如果你很急着用这个软件的话，也可以下载这个版本。 stable：稳定版。在开源软件中，都有stable版，这个就是开源软件的最终发行版，用户可以放心大胆的用了。 RELEASE：最终版本。在前面版本的一系列测试版之后，终归会有一个正式版本，是最终交付用户使用的一个版本。该版本有时也称为标准版。一般情况下，Release不会以单词形式出现在软件封面上，取而代之的是符号®。 发版流程 当开发达到发版要求、对某个版本进行了bug修复，或者新增相关内容之后，需要进行发版。 所有模块版本从 1.0.0 开始，基本的修改和bug修复后版本最后一位加1，即 1.1.0 &gt; 1.1.1。 当需要大版本发布时候，各组需要对中间版本进行升级，最后版本从0开始，即 1.1.X &gt; 1.2.0。 禁止在同一版本多次发布内容，每次发版版本号加1，请勿随意增减版本号。 发布操作源将本项目发布到nexus npm私有源仓库 进入到发布模块12$ cd packages/&lt; xxxx module&gt;$ yarn transpile 修改版本号修改模块文件下package.json中 version字段的值，手动+1 123\"version\": \"1.1.0\",// 手动加1\"version\": \"1.1.1\", 生成 auth hash**123echo -n 'username:password' | openssl base64# 得到 40位编码XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX username 和password需要找项目负责人进行提供。 配置npm config执行如下命令将上面的配置加入到node.js全局环境变量配置文件.npmrc中 1$ npm config edit 123email=your emailalways-auth=true_auth=yourbase64hashcode 发布1$ npm publish 查看 打开提供的源地址地址 找到自己刚刚发布的包 点击发布模块进入，看到最新版本已经改变，即为发布成功。","categories":[{"name":"版本控制","slug":"版本控制","permalink":"https://lokya.github.io/categories/版本控制/"}],"tags":[{"name":"版本控制","slug":"版本控制","permalink":"https://lokya.github.io/tags/版本控制/"}]},{"title":"前端分支管理","slug":"knowledge/git/gitManage","date":"2019-08-05T11:13:17.061Z","updated":"2019-08-05T11:35:09.333Z","comments":true,"path":"2019/08/05/knowledge/git/gitManage/","link":"","permalink":"https://lokya.github.io/2019/08/05/knowledge/git/gitManage/","excerpt":"","text":"前端分支管理背景最近要对前端分支管管理进一步规范化，于是就是现在公司项目中的分支管理进行总结和扩展，设计分支和管理规范。 由于项目采用 monorepo 模式，各个分组代码维护在 package 下面各个模块中，要做到各组开发方便，不同组间不干扰，同时也要可以实时测试开发环境，而且发版发布稳定版本，于是就指定如下的分支管理规范。 项目中对权限有所管控，由于部分人员的git水准实在不敢恭维，于是只有小组leader可以进行合并、升级等操作。 前言软件的版本控制以及分支管理贯穿于整个软件产品的生命周期，日常的项目管理对于开发团队能否有节奏且顺利的交付软件也很重要。 版本控制有很多种，例如我们常见的Git、SVN、VSS等，本项目中主要使用Git 进行版本控制。 Git分支管理模型有三个，即GitFlow、GitLabFlow、GitHubFlow。下面将介绍这三种分支模型的原理，使用场景和优缺点等 GitFlow GitFlow 是最早诞生并得到广泛应用的一种工作流程。 该模型中存在两种长期分支：master 和 develop。 master中存放对外发布的版本，只有稳定的发布版本才会合并到master中。 develop用于日常开发，存放最新的开发版本。 也存在三种临时分支：feature, hotfix, release。 feature分支是为了开发某个特定功能，从develop分支中切出，开发完成后合并到develop分支中。 hotfix分支是修复发布后发现的Bug的分支，从master分支中切出，修补完成后再合并到master和develop分支。 release分支指发布稳定版本前使用的预发布分支，从develop分支中切出，预发布完成后，合并到develop和master分支中。 优点： feature 分支使开发代码隔离，可以独立的完成开发、构建、测试 feature 分支开发周期长于release时，可避免未完成的feature进入生产环境 缺点： 无法支持持续发布。 过于复杂的分支管理，加重了开发者的负担，使开发者不能专注开发。 GitHubFlow GitHubFlow分支模型只存在一个master主分支，日常开发都合并至master，永远保持其为最新的代码且随时可发布的。 在需要添加或修改代码时， 基于master创建分支，提交修改。 创建Pull Request，所有人讨论和审查你的代码。 然后部署到生产环境中进行验证。 待验证通过后合并到master分支中。 这个分支模型的优势在于简洁易理解，将master作为核心的分支，代码更新持续集成至master上。根据目前收集到的反应来看，得到了更多的好评，认为GitHubFlow分支模型更加轻便快捷。 GitLabFlow GitLabFlow 是GitFlow和GitHubFlow的结合,它吸取了两者的优点，既有适应不同开发环境的弹性，又有单一主分支的简单和便利。 该模型采取上游优先的原则，即只存在一个master主分支，它是所以分支的上游。只有上游分支采纳的变动才能应用到其他分支。 对于持续发布的项目，建议在master之外再建立对应的环境分支，如预生产环境pre-production，生产环境production。 对于版本发布的项目，建议基于master创建稳定版本对应的分支，如stable-1，stable-2。 分支命名 前缀 含义 master 主分支，可用的、稳定的、可直接发布的版本 develop 开发主分支，最新的代码分支 publish 稳定发布分支 模块名称-dev 模块开发主分支 模块名称-工号 模块下个人开发分支 release-** 预发布分支 hotfix-** 已发布bug修复分支 1.x.x 例如1.1.x分支用于保留1.1.x版本中所有模块代码 分支管理 主分支 develop, master, publish全部被保护起来，禁止直接修改主分支以及把本地分支 push 到主分支。 主分支 develop,只能在 Gitlab 上通过 MergeRequests发起合并请求，并且只能由各组前端负责人在 Gitlab 上做合并。 主分支master,只能每天由负责人进行合并develop 到 master。 1.1.x 分支可以合并到除了master、publish 外的其他分支，一般通过这个分支进行升级相关包和文件。 xxxx-dev 分支可以发起合并请求到 develop. 禁止其他分支(例如: feature-xxx) 合并到 develop 分支。 个人的开发分支只能合并到各组的 xxxx-dev 分支。 大版本整体升级后，会保留前一版本的分支，如果有bug可以基于其建立1.x.x-hotfix分支对上面的bug进行修复。例如从1.1.10升级到1.2.0后，在1.1.x分支会保留1.1版本中所有代码，如果有bug基于1.1.x建立1.1.x-hotfix分支对bug进行修复。 分支管理图如下 提交规范提交步骤 git add 后执行 yarn commit。 要选择提交的类型。（可选类型如下）。 要填写提交的模块，例如srm-front-spfm。 要填写提交说明。例如：修复xxx导致的bug。 提交类型 类型 说明 build 主要目的是修改项目构建系统(例如 glup，webpack，rollup 的配置等)的提交 ci 主要目的是修改项目继续集成流程(例如 Travis，Jenkins，GitLab CI，Circle等)的提交 docs 文档更新 feat 新增功能 fix bug 修复 perf 性能优化 refactor 重构代码(既没有新增功能，也没有修复 bug) style 不影响程序逻辑的代码修改(修改空白字符，补全缺失的分号等) test 新增测试用例或是更新现有测试 revert 回滚某个更早之前的提交 chore 不属于以上类型的其他类型","categories":[{"name":"Git","slug":"Git","permalink":"https://lokya.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://lokya.github.io/tags/Git/"}]},{"title":"too many open files","slug":"notes/note1","date":"2019-06-14T02:43:02.332Z","updated":"2019-06-17T09:48:23.917Z","comments":true,"path":"2019/06/14/notes/note1/","link":"","permalink":"https://lokya.github.io/2019/06/14/notes/note1/","excerpt":"","text":"原因前端Jenkins跑服务时候报错，怎么都跑不起来，我就去服务器手动执行脚本。在build阶段发现服务器报错 too many open files,于是去查找资料找解决方案。 这个报错是只打来文件过多，超过了系统限制的文件数量以及通讯链接数，这边的files不单是文件的意思，也包括打开的通讯链接(比如socket)，正在监听的端口等，也可以叫做句柄(handle)。这个错误通常也可以叫做句柄数超出系统限制。 查看可以使用 ulimit -a 或者 ulimit -n 来查看当前系统最大句柄限制数 12345678910111213141516171819202122$ ulimit -acore file size (blocks, -c) 0data seg size (kbytes, -d) unlimitedscheduling priority (-e) 0file size (blocks, -f) unlimitedpending signals (-i) 127922max locked memory (kbytes, -l) 64max memory size (kbytes, -m) unlimitedopen files (-n) 1024pipe size (512 bytes, -p) 8POSIX message queues (bytes, -q) 819200real-time priority (-r) 0stack size (kbytes, -s) 8192cpu time (seconds, -t) unlimitedmax user processes (-u) 127922virtual memory (kbytes, -v) unlimitedfile locks (-x) unlimited$ limit -n1024 open files那一行就代表系统目前允许单个进程打开的最大句柄数，这里是1024。 同时使用 -n 查看下来也是1024。 修改临时修改ulimit -n 123456789101112131415161718192021222324$ ulimit -n 65535$ ulimit -acore file size (blocks, -c) 0data seg size (kbytes, -d) unlimitedscheduling priority (-e) 0file size (blocks, -f) unlimitedpending signals (-i) 127922max locked memory (kbytes, -l) 64max memory size (kbytes, -m) unlimitedopen files (-n) 65535pipe size (512 bytes, -p) 8POSIX message queues (bytes, -q) 819200real-time priority (-r) 0stack size (kbytes, -s) 8192cpu time (seconds, -t) unlimitedmax user processes (-u) 127922virtual memory (kbytes, -v) unlimitedfile locks (-x) unlimited$ limit -n65535 但这种设置方法在重启后会还原为默认值。 ulimit -n命令非root用户只能设置到4096，想要设置到更大需要sudo权限或者root用户。 修改conf文件，永久配置1234$ vim /etc/security/limits.conf #在最后加入 * soft nofile 65535 * hard nofile 65535 *代表所有用户，可以给特点用户设定句柄最大数值。 1234$ vim /etc/security/limits.conf #在最后加入 jenkins soft nofile 65535 jenkins hard nofile 65535 上面就是把jenkins用户最大句柄数改成65535 之后再查看大小的话可以发现已经修改为 65535 。","categories":[{"name":"linux","slug":"linux","permalink":"https://lokya.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://lokya.github.io/tags/linux/"},{"name":"note","slug":"note","permalink":"https://lokya.github.io/tags/note/"}]},{"title":"ES6-变量的解构","slug":"knowledge/es6/lesson_2","date":"2019-06-12T01:44:06.930Z","updated":"2019-06-17T11:03:58.007Z","comments":true,"path":"2019/06/12/knowledge/es6/lesson_2/","link":"","permalink":"https://lokya.github.io/2019/06/12/knowledge/es6/lesson_2/","excerpt":"","text":"(1) 数组12345678let [a, b, c] = [1, 2, 3];// 报错let [foo] = 1;let [foo] = false;let [foo] = NaN;let [foo] = undefined;let [foo] = null;let [foo] = &#123;&#125;; (2) 对象1let &#123; foo, bar &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;; 区分模式还是变量12345678910let obj = &#123; p: [ 'Hello', &#123; y: 'World' &#125; ]&#125;;let &#123; p: [x, &#123; y &#125;] &#125; = obj;x // \"Hello\"y // \"World\" 注意，这时p是模式，不是变量，因此不会被赋值注意: 默认值生效的条件是，对象的属性值严格等于undefined。 (3)字符串看做数组123456const [a, b, c, d, e] = 'hello';a // \"h\"b // \"e\"c // \"l\"d // \"l\"e // \"o\" (4)数值的布尔值12let &#123;toString: s&#125; = 123;s === Number.prototype.toString // true 解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错 (5)例子1234let x = 1;let y = 2;[x, y] = [y, x];","categories":[{"name":"javascript","slug":"javascript","permalink":"https://lokya.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://lokya.github.io/tags/javascript/"},{"name":"ES6","slug":"ES6","permalink":"https://lokya.github.io/tags/ES6/"}]},{"title":"声声慢","slug":"others/miscellany_2","date":"2019-05-09T15:04:08.281Z","updated":"2019-05-09T15:08:26.900Z","comments":true,"path":"2019/05/09/others/miscellany_2/","link":"","permalink":"https://lokya.github.io/2019/05/09/others/miscellany_2/","excerpt":"","text":"声声慢寻寻觅觅，冷冷清清，凄凄惨惨戚戚。乍暖还寒时候，最难将息。三杯两盏淡酒，怎敌他、晚来风急！雁过也，正伤心，却是旧时相识。 满地黄花堆积，憔悴损，如今有谁堪摘？守着窗儿，独自怎生得黑！梧桐更兼细雨，到黄昏、点点滴滴。这次第，怎一个愁字了得！ 怎一个愁字了得啊！","categories":[{"name":"杂记","slug":"杂记","permalink":"https://lokya.github.io/categories/杂记/"}],"tags":[{"name":"杂记","slug":"杂记","permalink":"https://lokya.github.io/tags/杂记/"}]},{"title":"论部门研发项目之怪现状","slug":"others/miscellany_1","date":"2019-05-07T14:53:51.127Z","updated":"2019-05-09T15:03:52.252Z","comments":true,"path":"2019/05/07/others/miscellany_1/","link":"","permalink":"https://lokya.github.io/2019/05/07/others/miscellany_1/","excerpt":"新产品开发已一年有余，每思项目中之事，无不发现其怪。此怪异有能者不作为，无能者空哀怨。。。。","text":"新产品开发已一年有余，每思项目中之事，无不发现其怪。此怪异有能者不作为，无能者空哀怨。。。。 怪现状一、从九干到九，天长又地久上班时间必须是早上9点上班到晚上9点下班，即使晚上没有什么工作内容。也必须坐到9点。9点已经变成一个闹钟，一个节点，甚至一个屏障。。。 怪现状二、早走你就走，好评我没有每次上班，拥有一种上学的感觉，不到点不能下课放学。只要有人早走，领导就会给黑脸看，评价降低，甚至增加工作量，强行加大开发时间。 怪现状三、苦劳别埋怨，不是我心愿总有同事开玩笑说加班累，周末没有时间。领导说又不是我让你待到9点后或者周末加班的，这是你自愿的。。。。 怪现状四、时间很不够，敏捷拿来凑每次定开发时间，都是直接上层拍板定时间。对项目的开发时间和测试发布时间不能很好的估计和评测，时间很紧。产品设计后开发的时间更加紧张，领导称之为敏捷开发模式。。。 怪现状五、需求天天改，结局没人采每次需求都各种变动，多个领导，多个产品。从不同角度不同思维进行修改，最终做出个什么样子后，没人再过问，都点头说ok。 怪现状六、技术常常换，项目玩不转项目人员不固定，今天来一个，明天撤项一个。代码把控一般，bug一堆，问题一堆。如何完好运行项目。","categories":[{"name":"杂记","slug":"杂记","permalink":"https://lokya.github.io/categories/杂记/"}],"tags":[{"name":"杂记","slug":"杂记","permalink":"https://lokya.github.io/tags/杂记/"}]},{"title":"个人摄影 - 第一期","slug":"shoot/shoot_1","date":"2019-05-06T09:16:38.802Z","updated":"2019-05-06T15:09:02.124Z","comments":true,"path":"2019/05/06/shoot/shoot_1/","link":"","permalink":"https://lokya.github.io/2019/05/06/shoot/shoot_1/","excerpt":"","text":"介绍 拍摄时间 - 2018年05月19日 地点 - 公司旁小路 闲谈天色阴暗，雨势渐小。雨珠在花和叶上欢乐的跳动。从叫做叶的平台跳下，落在地上，渗进土里。梦着下次和花的轮回。 备注图片是我自己拍的，如果要转发和使用，请打声招呼，或者注明出处。 请勿私自盗用，谢谢","categories":[{"name":"拍照摄影","slug":"拍照摄影","permalink":"https://lokya.github.io/categories/拍照摄影/"}],"tags":[{"name":"拍照摄影","slug":"拍照摄影","permalink":"https://lokya.github.io/tags/拍照摄影/"}]},{"title":"ES6-变量","slug":"knowledge/es6/lesson_1","date":"2019-05-06T08:50:20.293Z","updated":"2019-05-07T08:55:30.512Z","comments":true,"path":"2019/05/06/knowledge/es6/lesson_1/","link":"","permalink":"https://lokya.github.io/2019/05/06/knowledge/es6/lesson_1/","excerpt":"","text":"let 和 constlet声明变量，类似于var，但是let有作用域的概念。const 声明常量，一旦声明后，不可改变。const 声明后要立马初始化。 作用域 作用域顾名思义就是只有在某个区域内起作用。let 就只能在其作用域中起作用。 1234567&#123; let a = 10; var b = 1;&#125;a // ReferenceError: a is not defined.b // 1 变量提升 var 命令会发生“变量提升”现象，即变量可以在声明之前使用，值为undefined。 let 定义的变量如果在声明之前使用会报错。 暂时性死区 如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域（暂时性死区）。凡是在声明之前就使用这些变量，就会报错。 重复声明 let不允许在相同作用域内，重复声明同一个变量。 const本质 const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。 对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。 global对象顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。 ES5 之中，顶层对象的属性与全局变量是等价的。12345window.a = 1;a // 1a = 2;window.a // 2 为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性； let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性","categories":[{"name":"javascript","slug":"javascript","permalink":"https://lokya.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://lokya.github.io/tags/javascript/"},{"name":"ES6","slug":"ES6","permalink":"https://lokya.github.io/tags/ES6/"}]},{"title":"源","slug":"others/start","date":"2019-04-30T01:51:02.269Z","updated":"2019-05-06T15:09:08.465Z","comments":true,"path":"2019/04/30/others/start/","link":"","permalink":"https://lokya.github.io/2019/04/30/others/start/","excerpt":"","text":"原因我一直是一个不太喜欢写博客和文章的人，从业这么久，不喜欢去csdn或者博客园去发布文章。总觉得有时间还是看看书，娱乐娱乐比较好。忽然觉得有一个属于自己的地方，发点自己想想写的挺不错的。 打算想利用这个博客写点自己的东西，不论是技术分享还是技术笔记，或者生活杂记，都记录下来。例如拍个照片，可以发上来，这是一种记忆。 Emmmm其实也不知道说什么好，总之，希望利用好这个博客吧。","categories":[{"name":"杂记","slug":"杂记","permalink":"https://lokya.github.io/categories/杂记/"}],"tags":[]}]}